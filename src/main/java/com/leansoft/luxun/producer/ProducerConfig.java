/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.leansoft.luxun.producer;

import java.util.List;
import java.util.Properties;

import com.leansoft.luxun.common.annotations.ClientSide;
import com.leansoft.luxun.common.exception.InvalidConfigException;
import com.leansoft.luxun.message.generated.CompressionCodec;
import com.leansoft.luxun.producer.async.AsyncProducerConfig;
import com.leansoft.luxun.producer.async.AsyncProducerConfigShared;
import com.leansoft.luxun.utils.Utils;

/**
 * Configuration for producer
 * 
 * @author bulldog
 * 
 */
@ClientSide
public class ProducerConfig implements SyncProducerConfigShared, AsyncProducerConfigShared {

    private final SyncProducerConfigShared synchConfigShared;

    private final AsyncProducerConfigShared asyncProducerConfigShared;
    
    private Properties props;
    /**
     * create config for producer
     * @param props config arguments
     */
    public ProducerConfig(Properties props) {
        this.props = props;
        synchConfigShared = new SyncProducerConfig(props);
        asyncProducerConfigShared = new AsyncProducerConfig(props);
        check();
    }

    private void check() {
        // If both broker.list is not specified, throw an exception
        if (getBrokerList() == null) {
            throw new InvalidConfigException("broker.list must be specified in config");
        }
    }

    public Properties getProperties() {
        return props;
    }

    public int getConnectTimeoutMs() {
        return synchConfigShared.getConnectTimeoutMs();
    }

    public int getSocketTimeoutMs() {
        return synchConfigShared.getSocketTimeoutMs();
    }

    public int getReconnectCount() {
        return synchConfigShared.getReconnectCount();
    }

    public int getReconnectTimeInterval() {
        return synchConfigShared.getReconnectTimeInterval();
    }

    public int getMaxMessageSize() {
        return synchConfigShared.getMaxMessageSize();
    }

    public int getQueueTime() {
        return asyncProducerConfigShared.getQueueTime();
    }

    public int getQueueSize() {
        return asyncProducerConfigShared.getQueueSize();
    }

    public int getEnqueueTimeoutMs() {
        return asyncProducerConfigShared.getEnqueueTimeoutMs();
    }

    public int getBatchSize() {
        return asyncProducerConfigShared.getBatchSize();
    }

    public String getSerializerClass() {
        return synchConfigShared.getSerializerClass();
    }

    public String getCbkHandler() {
        return asyncProducerConfigShared.getCbkHandler();
    }

    public Properties getCbkHandlerProperties() {
        return asyncProducerConfigShared.getCbkHandlerProperties();
    }

    public String getEventHandler() {
        return asyncProducerConfigShared.getEventHandler();
    }

    public Properties getEventHandlerProperties() {
        return asyncProducerConfigShared.getEventHandlerProperties();
    }

    /**
     * use this config to pass in static broker. Format-
     * 
     * <pre>
     *      brokerid1:host1:port1, brokerid2:host2:port2
     * </pre>
     */
    public String getBrokerList() {
        return Utils.getString(props, "broker.list", null);
    }

    /**
     * This parameter allows you to specify the compression codec for all data generated by
     * this producer. The default is {@link CompressionCodec#NO_COMPRESSION}
     * 
     * @see CompressionCodec#NO_COMPRESSION
     */
    public CompressionCodec getCompressionCodec() {
        return CompressionCodec.findByValue(Utils.getInt(props, "compression.codec", 0));
    }

    /**
     * This parameter allows you to set whether compression should be turned * on for
     * particular topics
     * 
     * If the compression codec is anything other than NO_COMPRESSION,
     * 
     * Enable compression only for specified topics if any
     * 
     * If the list of compressed topics is empty, then enable the specified compression codec
     * for all topics
     * 
     * If the compression codec is NO_COMPRESSION, compression is disabled for all topics
     */
    public List<String> getCompressedTopics() {
        return Utils.getCSVList(Utils.getString(props, "compressed.topics", null));
    }

    /**
     * this parameter specifies whether the messages are sent asynchronously or not. Valid
     * values are
     * 
     * <pre>
     *   async: for asynchronous send 
     *    sync: for synchronous send
     * </pre>
     */
    public String getProducerType() {
        return Utils.getString(props, "producer.type", "sync");
    }

    /**
     * If DefaultEventHandler is used, this specifies the number of times to retry if an error
     * is encountered during send. 
     *
     */
    public int getNumRetries() {
        return Utils.getInt(props, "num.retries", 0);
    }
}
